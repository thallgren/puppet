module Puppet::Pops
module Types

# @api private
class RubyGenerator < TypeFormatter
  def remove_common_namespace(namespace_segments, name)
    segments = name.split(TypeFormatter::NAME_SEGMENT_SEPARATOR)
    namespace_segments.size.times do |idx|
      break if segments.empty? || namespace_segments[idx] != segments[0]
      segments.shift
    end
    segments
  end

  def namespace_relative(namespace_segments, name)
    remove_common_namespace(namespace_segments, name).join(TypeFormatter::NAME_SEGMENT_SEPARATOR)
  end

  def create_class(obj)
    @dynamic_classes ||= Hash.new do |hash, key|
      cls = key.implementation_class(false)
      if cls.nil?
        rp = key.resolved_parent
        parent_class = rp.is_a?(PObjectType) ? rp.implementation_class : Object
        class_def = ''
        class_body(key, EMPTY_ARRAY, class_def)
        cls = Class.new(parent_class)
        cls.class_eval(class_def)
        cls.define_singleton_method(:_ptype) { return key }
        key.implementation_class = cls
      end
      hash[key] = cls
    end
    raise ArgumentError, "Expected a Puppet Type, got '#{obj.class.name}'" unless obj.is_a?(PAnyType)
    @dynamic_classes[obj]
  end

  def module_definition_from_typeset(typeset, *impl_subst)
    module_definition(
      typeset.types.values,
      "# Generated by #{self.class.name} from TypeSet #{typeset.name} on #{Date.new}\n",
      *impl_subst)
  end

  def module_definition(types, comment, *impl_subst)
    object_types, aliased_types = types.partition { |type| type.is_a?(PObjectType) }
    if impl_subst.empty?
      impl_names = implementation_names(object_types)
    else
      impl_names = object_types.map { |type| type.name.gsub(*impl_subst) }
    end

    # extract common implementation module prefix
    names_by_prefix = Hash.new { |hash, key| hash[key] = [] }
    index = 0
    min_prefix_length = impl_names.reduce(Float::INFINITY) do |len, impl_name|
      segments = impl_name.split(TypeFormatter::NAME_SEGMENT_SEPARATOR)
      leaf_name = segments.pop
      names_by_prefix[segments.freeze] << [index, leaf_name, impl_name]
      index += 1
      len > segments.size ? segments.size : len
    end

    common_prefix = []
    segments_array = names_by_prefix.keys
    min_prefix_length.times do |idx|
      segment = segments_array[0][idx]
      break unless segments_array.all? { |sn| sn[idx] == segment }
      common_prefix << segment
    end

    # Create class definition of all contained types
    bld = ''
    start_module(common_prefix, comment, bld)
    class_names = []
    names_by_prefix.each_pair do |segments_array, index_and_name_array|
      added_to_common_prefix = segments_array[common_prefix.length..-1]
      added_to_common_prefix.each { |name| bld << 'module ' << name << "\n" }
      index_and_name_array.each do |idx, name, full_name|
        scoped_class_definition(object_types[idx], name, bld, full_name, *impl_subst)
        class_names << (added_to_common_prefix + [name]).join(TypeFormatter::NAME_SEGMENT_SEPARATOR)
        bld << "\n"
      end
      added_to_common_prefix.size.times { bld << "end\n" }
    end

    aliases = Hash[aliased_types.map { |type| [type.name, type.resolved_type] }]
    end_module(common_prefix, aliases, class_names, bld)
    bld
  end

  def start_module(common_prefix, comment, bld)
    bld << '# ' << comment << "\n"
    common_prefix.each { |cp| bld << 'module ' << cp << "\n" }
  end

  def end_module(common_prefix, aliases, class_names, bld)
    # Emit registration of contained type aliases
    unless aliases.empty?
      bld << "Puppet::Pops::Pcore.register_aliases({\n"
      aliases.each { |name, type| bld << "  '" << name << "' => " << TypeFormatter.string(type.to_s) << "\n" }
      bld.chomp!(",\n")
      bld << "})\n\n"
    end

    # Emit registration of contained types
    unless class_names.empty?
      bld << "Puppet::Pops::Pcore.register_implementations([\n"
      class_names.each { |class_name| bld << '  ' << class_name << ",\n" }
      bld.chomp!(",\n")
      bld << "])\n\n"
    end
    bld.chomp!("\n")

    common_prefix.size.times { bld << "end\n" }
  end

  def implementation_names(object_types)
    object_types.map do |type|
      ir = Loaders.implementation_registry
      impl_name = ir.module_name_for_type(type)
      raise Puppet::Error, "Unable to create an instance of #{type.name}. No mapping exists to runtime object" if impl_name.nil?
      impl_name[0]
    end
  end

  def class_definition(obj, namespace_segments, bld, class_name, *impl_subst)
    module_segments = remove_common_namespace(namespace_segments, class_name)
    leaf_name = module_segments.pop
    module_segments.each { |segment| bld << 'module ' << segment << "\n" }
    scoped_class_definition(obj,leaf_name, bld, class_name, *impl_subst)
    module_segments.size.times { bld << "end\n" }
    module_segments << leaf_name
    module_segments.join(TypeFormatter::NAME_SEGMENT_SEPARATOR)
  end

  def scoped_class_definition(obj, leaf_name, bld, class_name, *impl_subst)
    bld << 'class ' << leaf_name
    segments = class_name.split(TypeFormatter::NAME_SEGMENT_SEPARATOR)

    unless obj.parent.nil?
      if impl_subst.empty?
        ir = Loaders.implementation_registry
        parent_impl = ir.module_name_for_type(obj.parent)
        raise Puppet::Error, "Unable to create an instance of #{obj.parent.name}. No mapping exists to runtime object" if parent_impl.nil?
        parent_name = parent_impl[0]
      else
        parent_name = obj.parent.name.gsub(*impl_subst)
      end
      bld << ' < ' << namespace_relative(segments, parent_name)
    end

    bld << "\n"
    bld << "  def self._plocation\n"
    bld << "    loc = Puppet::Util.path_to_uri(\"\#{__FILE__}\")\n"
    bld << "    URI(\"#\{loc}?line=#\{__LINE__.to_i - 3}\")\n"
    bld << "  end\n"

    bld << "\n"
    bld << "  def self._ptype\n"
    bld << '    @_ptype ||= ' << namespace_relative(segments, obj.class.name) << ".new('" << obj.name << "',\n"
    bld << TypeFormatter.new.ruby_string('ref', 3, obj.i12n_hash(false)) << "    )\n"
    bld << "  end\n"

    class_body(obj, segments, bld)

    bld << "end\n"
  end

  def class_body(obj, segments, bld)
    if obj.parent.nil?
      bld << "\n  include " << namespace_relative(segments, Puppet::Pops::Types::PuppetObject.name) << "\n\n" # marker interface
      bld << "  def self.ref(type_string)\n"
      bld << '    ' << namespace_relative(segments, Puppet::Pops::Types::PTypeReferenceType.name) << ".new(type_string)\n"
      bld << "  end\n"
    end

    # Output constants
    constants, others = obj.attributes(true).values.partition { |a| a.kind == PObjectType::ATTRIBUTE_KIND_CONSTANT }
    constants = constants.select { |ca| ca.container.equal?(obj) }
    unless constants.empty?
      constants.each { |ca| bld << "\n  def self." << ca.name << "\n    _ptype['" << ca.name << "'].value\n  end\n" }
      constants.each { |ca| bld << "\n  def " << ca.name << "\n    self.class." << ca.name << "\n  end\n" }
    end

    init_params = others.reject { |a| a.kind == PObjectType::ATTRIBUTE_KIND_DERIVED }
    opt, non_opt = init_params.partition { |ip| ip.value? }

    # Output type safe hash constructor
    bld << "\n  def self.from_hash(i12n)\n"
    bld << '    from_asserted_hash(' << namespace_relative(segments, TypeAsserter.name) << '.assert_instance_of('
    bld << "'" << obj.label << " initializer', _ptype.i12n_type, i12n))\n  end\n\n  def self.from_asserted_hash(i12n)\n    new"
    unless non_opt.empty? && opt.empty?
      bld << "(\n"
      non_opt.each { |ip| bld << "      i12n['" << ip.name << "'],\n" }
      opt.each { |ip| bld << "      i12n.fetch('" << ip.name << "') { _ptype['" << ip.name << "'].value },\n" }
      bld.chomp!(",\n")
      bld << ')'
    end
    bld << "\n  end\n"

    # Output type safe constructor
    bld << "\n  def self.create"
    if init_params.empty?
      bld << "\n    new"
    else
      bld << '('
      non_opt.each { |ip| bld << ip.name << ', ' }
      opt.each { |ip| bld << ip.name << ' = ' << "_ptype['#{ip.name}'].value" << ', ' }
      bld.chomp!(', ')
      bld << ")\n"
      bld << '    ta = ' << namespace_relative(segments, TypeAsserter.name) << "\n"
      bld << "    attrs = _ptype.attributes(true)\n"
      init_params.each do |a|
        bld << "    ta.assert_instance_of('" << a.container.name << '[' << a.name << ']'
        bld << "', attrs['" << a.name << "'].type, " << a.name << ")\n"
      end
      bld << '    new('
      non_opt.each { |a| bld << a.name << ', ' }
      opt.each { |a| bld << a.name << ', ' }
      bld.chomp!(', ')
      bld << ')'
    end
    bld << "\n  end\n"

    unless init_params.empty?
      # Output initializer
      bld << "\n  def initialize"
      bld << '('
      non_opt.each { |ip| bld << ip.name << ', ' }
      opt.each { |ip| bld << ip.name << ' = ' << "_ptype['#{ip.name}'].value" << ', ' }
      bld.chomp!(', ')
      bld << ')'
      unless obj.parent.nil?
        bld << "\n    super("
        super_args = (non_opt + opt).select { |ip| !ip.container.equal?(obj) }
        unless super_args.empty?
          super_args.each { |ip| bld << ip.name << ', ' }
          bld.chomp!(', ')
        end
        bld << ')'
      end
      bld << "\n"
      init_params.each { |a| bld << '    @' << a.name << ' = ' << a.name << "\n" if a.container.equal?(obj) }
      bld << "  end\n"
    end


    bld << "\n  def i12n_hash\n"
    if obj.parent.nil? && init_params.empty?
      bld << '    {}'
    else
      bld << "    result = "
      bld << (obj.parent.nil? ? '{}' : 'super')
      bld << "\n"
      init_params.each do |a|
        next unless a.container.equal?(obj)
        bld << "    result['" << a.name << "'] = @" << a.name
        if a.value?
          bld << ' unless '
          case a.value
            when nil, true, false, Numeric, String
              bld << '@' << a.name << ' == ' << a.value.inspect
            else
              bld << "_ptype['" << a.name << "'].is_default?(@" << a.name << ')'
          end
        end
        bld << "\n"
      end
      bld << '    result'
    end
    bld << "\n  end\n"

    bld << "\n  def to_s\n"
    bld << "    " << namespace_relative(segments, TypeFormatter.name) << ".string(self)\n"
    bld << "  end\n\n"

    # Output attr_readers
    others.each do |a|
      next unless a.container.equal?(obj)
      if a.kind == PObjectType::ATTRIBUTE_KIND_DERIVED || a.kind == PObjectType::ATTRIBUTE_KIND_GIVEN_OR_DERIVED
        bld << '  def ' << a.name << "\n"
        bld << "    raise Puppet::Error, \"no method is implemented for derived attribute #{a.label}\"\n"
        bld << "  end\n"
      else
        bld << '  attr_reader :' << a.name << "\n"
      end
    end

    # Output function placeholders
    obj.functions(false).each_value do |func|
      bld << "\n  def " << func.name << "(*args)\n"
      bld << "    # Placeholder for #{func.type}\n"
      bld << "    raise Puppet::Error, \"no method is implemented for #{func.label}\"\n"
      bld << "  end\n"
    end

    # output hash and equality
    include_class = obj.include_class_in_equality?
    if obj.equality.nil?
      eq_names = obj.attributes(false).values.select { |a| a.kind != PObjectType::ATTRIBUTE_KIND_CONSTANT }.map(&:name)
    else
      eq_names = obj.equality
    end

    unless eq_names.empty? && !include_class
      bld << "\n  def hash\n    "
      bld << 'super.hash ^ ' unless obj.parent.nil?
      if eq_names.empty?
        bld << "self.class.hash\n"
      else
        bld << '['
        bld << 'self.class, ' if include_class
        eq_names.each { |eqn| bld << '@' << eqn << ', ' }
        bld.chomp!(', ')
        bld << "].hash\n"
      end
      bld << "  end\n"

      bld << "\n  def eql?(o)\n"
      bld << "    super &&\n" unless obj.parent.nil?
      bld << "    self.class.eql?(o.class) &&\n" if include_class
      eq_names.each { |eqn| bld << '    @' << eqn << '.eql?(o.' <<  eqn << ") &&\n" }
      bld.chomp!(" &&\n")
      bld << "\n  end\n  alias == eql?\n"
    end
  end
end
end
end
